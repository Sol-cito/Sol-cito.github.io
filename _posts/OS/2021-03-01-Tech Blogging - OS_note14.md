---
layout: post
title: "[OS] 파일시스템 & 부팅"
subtitle: "운영체제 마지막 강의"
background: '/img/bg_technology.jpg'
categories: technology-os
---


#### 파일시스템

운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘을 뜻한다.

파일 시스템이 만들어진 이유는 무엇일까?

원래 컴퓨터는 0과 1의 데이터를 저장매체에 저장하는 장치였는데,

비트로 관리하기에는 관리가 어렵고, 오버헤드가 컸기에, 블록 단위로 관리하는 등의 방법을 도입했다.

그러나 블록 고유번호로 관리하기에도 일반 사용자에게 어려웠기 때문에...

**사용자가 이해하기 쉬운 추상적(논리적)인 객체가 필요했고, 그것이 'FIle'이다.**

즉, **사용자는 파일 단위로 관리**하고, **내부 컴퓨터는 각 파일에 따른 Block 단위로 관라**하도록 분리하였고,

이것이 파일 시스템의 시초이다.

처음에는 파일을 저장할 때, **연속적인 공간에 저장**하는 것이 효율적이지 않겠냐는 생각을 하겠으나,

그 경우 **외부 단편화의 문제**가 발생한다.

즉, 파일 사이즈가 가변적이면, 파일을 완벽하게 연속적인 공간에 저장하는 것은 불가능하다.

이 문제를 해결하기 위한 방법이 나왔는데,

- **Block Chain : **'Linked List'의 형태로, 블록 조각들을 이곳 저곳에 연결하는 방법이다. 단점으로는, 맨 끝에 있는 블록을 찾으려먼 맨 처음 블록부터 주소를 계속 따라가야 하는 단점이 있다.
- **Index Block** : 각 블록에 대한 위치 정보를 기록해서, 한 번에 끝 블록을 찾아갈 수 있도록 하였다.

윈도우의 파일 시스템은 **FAT, FAT32, NTFS**가 있다(블록위치를 FAT라는 자료 구조에 기록).

리눅스는 **ext2, ext3, ext4**가 있고, 일종의 인덱스  블록 기법인 **inode방식**을 사용한다.

각 운영체제에서 read/write 시스템 콜 호출 시, 각 기기 및 파일 시스템에 따라 실질적인 처리를 담당하는 함수를 구현하였다.

즉, 개발자는 굳이 어떤 파일 시스템을 사용할지를 고민하지 않고서도, **운영체제가 알아서 시스템콜을 구현해놓은 것.**

<br>

#### 부팅(Booting)

부팅이란 **컴퓨터를 켜서 동작시키는 절차**이며, 부팅을 위해서도 **프로그램이 필요하며, 이를 '부트 프로그램'이라 한다**.

부트 프로그램은 **운영체제 커널**을 Strage에서 특정 주소의 물리메모리로 복사하고,

커널의 처음 실행위치로 Program Counter를 가져다놓는 역할을 한다 (폰노이만 구조).

컴퓨터를 켜면,

- 일단 RAM에는 아무것도 없다.

- 컴퓨터가 켜지면, CPU가 **ROM-BIOS**(특별한 RAM)를 읽고 **Bootstrap loader를 메모리에 올리고 실행한다.**

  (왜 BIOS RAM에서 바로 Bootstrap을 실행시키지 않는가? **BIOS RAM은 느려서...**)

- BIOS 프로그램은 두 가지 기능이 있다.

  - 하드웨어 초기화
  - RAM의 첫 공간**(Master Boot Record)**을 찾아간다.
  - Master Boot Record 안의 내용은 **Boot Loader**로,  BIOS가 이 부트로더를 RAM에 올린다.
  - 부트로더에는 **파티션 테이블의 정보 & 운영체제 정보**가 들어있고, 이 정보가 RAM에 올라간다.

- 다음, 부트 섹터에서 부트 코드가 로딩되고, 그 다음 커널 이미지가 RAM에 올라가며 **운영체제 이미지**가 로드된다.
- 이렇게 비로소 컴퓨터가 시작되고 운영체제의 "환영합니다" 화면이 뜨게 된다.

<br>
---
위 내용은 '패스트캠퍼스'의 컴퓨터공학 강좌 내용을 요약 정리한 것임을 밝힙니다.
(https://www.fastcampus.co.kr/)



